import { CompilerContext } from "./context";
import { AstBinaryOperation, AstBoolean, AstCondition, AstConditional, AstConstantDef, AstContract, AstExpression, AstFieldAccess, AstFunctionDef, AstId, AstInitOf, AstMessageDecl, AstMethodCall, AstModuleItem, AstNativeFunctionDecl, AstNull, AstNumber, AstOpBinary, AstOpUnary, AstPrimitiveTypeDecl, AstStatement, AstStatementAssign, AstStatementAugmentedAssign, AstStatementExpression, AstStatementForEach, AstStatementLet, AstStatementRepeat, AstStatementReturn, AstStatementTry, AstStatementTryCatch, AstStatementUntil, AstStatementWhile, AstStaticCall, AstString, AstStructDecl, AstStructInstance, AstTrait, AstUnaryOperation } from "./grammar/ast";
import { SrcInfo } from "./grammar/grammar";
import { StructValue, Value } from "./types/types";
export declare function throwNonFatalErrorConstEval(msg: string, source: SrcInfo): never;
type EvalResult = {
    kind: "ok";
    value: Value;
} | {
    kind: "error";
    message: string;
};
export declare function ensureInt(val: Value, source: SrcInfo): bigint;
export declare function evalUnaryOp(op: AstUnaryOperation, valOperand: Value, operandLoc?: SrcInfo, source?: SrcInfo): Value;
export declare function evalBinaryOp(op: AstBinaryOperation, valLeft: Value, valRight: Value, locLeft?: SrcInfo, locRight?: SrcInfo, source?: SrcInfo): Value;
type InterpreterConfig = {
    maxLoopIterations: bigint;
};
export declare function parseAndEvalExpression(sourceCode: string): EvalResult;
export declare class Interpreter {
    private envStack;
    private context;
    private config;
    constructor(context?: CompilerContext, config?: InterpreterConfig);
    interpretModuleItem(ast: AstModuleItem): void;
    interpretConstantDef(ast: AstConstantDef): void;
    interpretFunctionDef(ast: AstFunctionDef): void;
    interpretStructDecl(ast: AstStructDecl): void;
    interpretMessageDecl(ast: AstMessageDecl): void;
    interpretPrimitiveTypeDecl(ast: AstPrimitiveTypeDecl): void;
    interpretFunctionDecl(ast: AstNativeFunctionDecl): void;
    interpretContract(ast: AstContract): void;
    interpretTrait(ast: AstTrait): void;
    interpretExpression(ast: AstExpression): Value;
    interpretName(ast: AstId): Value;
    interpretMethodCall(ast: AstMethodCall): Value;
    interpretInitOf(ast: AstInitOf): Value;
    interpretNull(_ast: AstNull): null;
    interpretBoolean(ast: AstBoolean): boolean;
    interpretNumber(ast: AstNumber): bigint;
    interpretString(ast: AstString): string;
    interpretUnaryOp(ast: AstOpUnary): Value;
    interpretBinaryOp(ast: AstOpBinary): Value;
    interpretConditional(ast: AstConditional): Value;
    interpretStructInstance(ast: AstStructInstance): StructValue;
    interpretFieldAccess(ast: AstFieldAccess): Value;
    interpretStaticCall(ast: AstStaticCall): Value;
    private evalStaticFunction;
    interpretStatement(ast: AstStatement): void;
    interpretLetStatement(ast: AstStatementLet): void;
    interpretAssignStatement(ast: AstStatementAssign): void;
    interpretAugmentedAssignStatement(ast: AstStatementAugmentedAssign): void;
    interpretConditionStatement(ast: AstCondition): void;
    interpretExpressionStatement(ast: AstStatementExpression): void;
    interpretForEachStatement(ast: AstStatementForEach): void;
    interpretRepeatStatement(ast: AstStatementRepeat): void;
    interpretReturnStatement(ast: AstStatementReturn): void;
    interpretTryStatement(ast: AstStatementTry): void;
    interpretTryCatchStatement(ast: AstStatementTryCatch): void;
    interpretUntilStatement(ast: AstStatementUntil): void;
    interpretWhileStatement(ast: AstStatementWhile): void;
}
export {};
