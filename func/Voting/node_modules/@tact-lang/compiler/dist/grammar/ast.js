"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SrcInfo = exports.selfId = void 0;
exports.idText = idText;
exports.isInt = isInt;
exports.isBool = isBool;
exports.isCell = isCell;
exports.isSlice = isSlice;
exports.isBuilder = isBuilder;
exports.isAddress = isAddress;
exports.isString = isString;
exports.isStringBuilder = isStringBuilder;
exports.isSelfId = isSelfId;
exports.isWildcard = isWildcard;
exports.isRequire = isRequire;
exports.eqNames = eqNames;
exports.idOfText = idOfText;
exports.astNumToString = astNumToString;
exports.tryExtractPath = tryExtractPath;
exports.createAstNode = createAstNode;
exports.cloneAstNode = cloneAstNode;
exports.__DANGER_resetNodeId = __DANGER_resetNodeId;
exports.eqExpressions = eqExpressions;
exports.isValue = isValue;
const grammar_1 = require("./grammar");
Object.defineProperty(exports, "SrcInfo", { enumerable: true, get: function () { return grammar_1.SrcInfo; } });
function idText(ident) {
    return ident.text;
}
function isInt(ident) {
    return ident.text === "Int";
}
function isBool(ident) {
    return ident.text === "Bool";
}
function isCell(ident) {
    return ident.text === "Cell";
}
function isSlice(ident) {
    return ident.text === "Slice";
}
function isBuilder(ident) {
    return ident.text === "Builder";
}
function isAddress(ident) {
    return ident.text === "Address";
}
function isString(ident) {
    return ident.text === "String";
}
function isStringBuilder(ident) {
    return ident.text === "StringBuilder";
}
function isSelfId(ident) {
    return ident.text === "self";
}
function isWildcard(ident) {
    return ident.text === "_";
}
function isRequire(ident) {
    return ident.text === "require";
}
function eqNames(left, right) {
    if (typeof left === "string") {
        if (typeof right === "string") {
            return left === right;
        }
        return left === right.text;
    }
    else {
        if (typeof right === "string") {
            return left.text === right;
        }
        return left.text === right.text;
    }
}
function idOfText(text) {
    return {
        kind: "id",
        text,
        id: 0,
        loc: grammar_1.dummySrcInfo,
    };
}
exports.selfId = {
    kind: "id",
    text: "self",
    id: 0,
    loc: grammar_1.dummySrcInfo,
};
function astNumToString(n) {
    switch (n.base) {
        case 2:
            return `0b${n.value.toString(n.base)}`;
        case 8:
            return `0o${n.value.toString(n.base)}`;
        case 10:
            return n.value.toString(n.base);
        case 16:
            return `0x${n.value.toString(n.base)}`;
    }
}
/**
 * Check if input expression is a 'path expression',
 * i.e. an identifier or a sequence of field accesses starting from an identifier.
 * @param path A path expression to check.
 * @returns An array of identifiers or null if the input expression is not a path expression.
 */
function tryExtractPath(path) {
    switch (path.kind) {
        case "id":
            return [path];
        case "field_access": {
            const p = tryExtractPath(path.aggregate);
            return p ? [...p, path.field] : null;
        }
        default:
            return null;
    }
}
let nextId = 1;
function createAstNode(src) {
    return Object.freeze(Object.assign({ id: nextId++ }, src));
}
function cloneAstNode(src) {
    return { ...src, id: nextId++ };
}
function __DANGER_resetNodeId() {
    nextId = 1;
}
// Test equality of AstExpressions.
function eqExpressions(ast1, ast2) {
    if (ast1.kind !== ast2.kind) {
        return false;
    }
    switch (ast1.kind) {
        case "null":
            return true;
        case "boolean":
            return ast1.value === ast2.value;
        case "number":
            return ast1.value === ast2.value;
        case "string":
            return ast1.value === ast2.value;
        case "id":
            return eqNames(ast1, ast2);
        case "method_call":
            return (eqNames(ast1.method, ast2.method) &&
                eqExpressions(ast1.self, ast2.self) &&
                eqExpressionArrays(ast1.args, ast2.args));
        case "init_of":
            return (eqNames(ast1.contract, ast2.contract) &&
                eqExpressionArrays(ast1.args, ast2.args));
        case "op_unary":
            return (ast1.op === ast2.op &&
                eqExpressions(ast1.operand, ast2.operand));
        case "op_binary":
            return (ast1.op === ast2.op &&
                eqExpressions(ast1.left, ast2.left) &&
                eqExpressions(ast1.right, ast2.right));
        case "conditional":
            return (eqExpressions(ast1.condition, ast2.condition) &&
                eqExpressions(ast1.thenBranch, ast2.thenBranch) &&
                eqExpressions(ast1.elseBranch, ast2.elseBranch));
        case "struct_instance":
            return (eqNames(ast1.type, ast2.type) &&
                eqParameterArrays(ast1.args, ast2.args));
        case "field_access":
            return (eqNames(ast1.field, ast2.field) &&
                eqExpressions(ast1.aggregate, ast2.aggregate));
        case "static_call":
            return (eqNames(ast1.function, ast2.function) &&
                eqExpressionArrays(ast1.args, ast2.args));
    }
}
function eqParameters(arg1, arg2) {
    return (eqNames(arg1.field, arg2.field) &&
        eqExpressions(arg1.initializer, arg2.initializer));
}
function eqParameterArrays(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (!eqParameters(arr1[i], arr2[i])) {
            return false;
        }
    }
    return true;
}
function eqExpressionArrays(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (!eqExpressions(arr1[i], arr2[i])) {
            return false;
        }
    }
    return true;
}
function isValue(ast) {
    switch (ast.kind) {
        case "null":
        case "boolean":
        case "number":
        case "string":
            return true;
        case "struct_instance":
            return ast.args.every((arg) => isValue(arg.initializer));
        case "id":
        case "method_call":
        case "init_of":
        case "op_unary":
        case "op_binary":
        case "conditional":
        case "field_access":
        case "static_call":
            return false;
    }
}
