"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalConstantExpression = evalConstantExpression;
exports.partiallyEvalExpression = partiallyEvalExpression;
const ast_1 = require("./grammar/ast");
const errors_1 = require("./errors");
const util_1 = require("./optimizer/util");
const standardOptimizer_1 = require("./optimizer/standardOptimizer");
const interpreter_1 = require("./interpreter");
// The optimizer that applies the rewriting rules during partial evaluation.
// For the moment we use an optimizer that respects overflows.
const optimizer = new standardOptimizer_1.StandardOptimizer();
function partiallyEvalUnaryOp(op, operand, source, ctx) {
    if (operand.kind === "number" && op === "-") {
        // emulating negative integer literals
        return (0, util_1.makeValueExpression)((0, interpreter_1.ensureInt)(-operand.value, source));
    }
    const simplOperand = partiallyEvalExpression(operand, ctx);
    if ((0, ast_1.isValue)(simplOperand)) {
        const valueOperand = (0, util_1.extractValue)(simplOperand);
        const result = (0, interpreter_1.evalUnaryOp)(op, valueOperand, simplOperand.loc, source);
        // Wrap the value into a Tree to continue simplifications
        return (0, util_1.makeValueExpression)(result);
    }
    else {
        const newAst = (0, util_1.makeUnaryExpression)(op, simplOperand);
        return optimizer.applyRules(newAst);
    }
}
function partiallyEvalBinaryOp(op, left, right, source, ctx) {
    const leftOperand = partiallyEvalExpression(left, ctx);
    const rightOperand = partiallyEvalExpression(right, ctx);
    if ((0, ast_1.isValue)(leftOperand) && (0, ast_1.isValue)(rightOperand)) {
        const valueLeftOperand = (0, util_1.extractValue)(leftOperand);
        const valueRightOperand = (0, util_1.extractValue)(rightOperand);
        const result = (0, interpreter_1.evalBinaryOp)(op, valueLeftOperand, valueRightOperand, leftOperand.loc, rightOperand.loc, source);
        // Wrap the value into a Tree to continue simplifications
        return (0, util_1.makeValueExpression)(result);
    }
    else {
        const newAst = (0, util_1.makeBinaryExpression)(op, leftOperand, rightOperand);
        return optimizer.applyRules(newAst);
    }
}
function evalConstantExpression(ast, ctx) {
    const interpreter = new interpreter_1.Interpreter(ctx);
    const result = interpreter.interpretExpression(ast);
    return result;
}
function partiallyEvalExpression(ast, ctx) {
    const interpreter = new interpreter_1.Interpreter(ctx);
    switch (ast.kind) {
        case "id":
            try {
                return (0, util_1.makeValueExpression)(interpreter.interpretName(ast));
            }
            catch (e) {
                if (e instanceof errors_1.TactConstEvalError) {
                    if (!e.fatal) {
                        // If a non-fatal error occurs during lookup, just return the symbol
                        return ast;
                    }
                }
                throw e;
            }
        case "method_call":
            // Does not partially evaluate at the moment. Will attempt to fully evaluate
            return (0, util_1.makeValueExpression)(interpreter.interpretMethodCall(ast));
        case "init_of":
            (0, interpreter_1.throwNonFatalErrorConstEval)("initOf is not supported at this moment", ast.loc);
            break;
        case "null":
            return ast;
        case "boolean":
            return ast;
        case "number":
            return (0, util_1.makeValueExpression)(interpreter.interpretNumber(ast));
        case "string":
            return (0, util_1.makeValueExpression)(interpreter.interpretString(ast));
        case "op_unary":
            return partiallyEvalUnaryOp(ast.op, ast.operand, ast.loc, ctx);
        case "op_binary":
            return partiallyEvalBinaryOp(ast.op, ast.left, ast.right, ast.loc, ctx);
        case "conditional":
            // Does not partially evaluate at the moment. Will attempt to fully evaluate
            return (0, util_1.makeValueExpression)(interpreter.interpretConditional(ast));
        case "struct_instance":
            // Does not partially evaluate at the moment. Will attempt to fully evaluate
            return (0, util_1.makeValueExpression)(interpreter.interpretStructInstance(ast));
        case "field_access":
            // Does not partially evaluate at the moment. Will attempt to fully evaluate
            return (0, util_1.makeValueExpression)(interpreter.interpretFieldAccess(ast));
        case "static_call":
            // Does not partially evaluate at the moment. Will attempt to fully evaluate
            return (0, util_1.makeValueExpression)(interpreter.interpretStaticCall(ast));
    }
}
