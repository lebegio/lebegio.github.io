"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractValue = extractValue;
exports.makeValueExpression = makeValueExpression;
exports.makeUnaryExpression = makeUnaryExpression;
exports.makeBinaryExpression = makeBinaryExpression;
exports.checkIsUnaryOpNode = checkIsUnaryOpNode;
exports.checkIsBinaryOpNode = checkIsBinaryOpNode;
exports.checkIsBinaryOp_With_RightValue = checkIsBinaryOp_With_RightValue;
exports.checkIsBinaryOp_With_LeftValue = checkIsBinaryOp_With_LeftValue;
exports.checkIsNumber = checkIsNumber;
exports.checkIsName = checkIsName;
exports.checkIsBoolean = checkIsBoolean;
exports.divFloor = divFloor;
exports.abs = abs;
exports.sign = sign;
exports.modFloor = modFloor;
const ast_1 = require("../grammar/ast");
const grammar_1 = require("../grammar/grammar");
const errors_1 = require("../errors");
function extractValue(ast) {
    switch (ast.kind // Missing structs
    ) {
        case "null":
            return null;
        case "boolean":
            return ast.value;
        case "number":
            return ast.value;
        case "string":
            return ast.value;
    }
}
function makeValueExpression(value) {
    if (value === null) {
        const result = (0, ast_1.createAstNode)({
            kind: "null",
            loc: grammar_1.dummySrcInfo,
        });
        return result;
    }
    if (typeof value === "string") {
        const result = (0, ast_1.createAstNode)({
            kind: "string",
            value: value,
            loc: grammar_1.dummySrcInfo,
        });
        return result;
    }
    if (typeof value === "bigint") {
        const result = (0, ast_1.createAstNode)({
            kind: "number",
            base: 10,
            value: value,
            loc: grammar_1.dummySrcInfo,
        });
        return result;
    }
    if (typeof value === "boolean") {
        const result = (0, ast_1.createAstNode)({
            kind: "boolean",
            value: value,
            loc: grammar_1.dummySrcInfo,
        });
        return result;
    }
    (0, errors_1.throwInternalCompilerError)(`structs, addresses, cells, and comment values are not supported at the moment.`);
}
function makeUnaryExpression(op, operand) {
    const result = (0, ast_1.createAstNode)({
        kind: "op_unary",
        op: op,
        operand: operand,
        loc: grammar_1.dummySrcInfo,
    });
    return result;
}
function makeBinaryExpression(op, left, right) {
    const result = (0, ast_1.createAstNode)({
        kind: "op_binary",
        op: op,
        left: left,
        right: right,
        loc: grammar_1.dummySrcInfo,
    });
    return result;
}
// Checks if the top level node is an unary op node
function checkIsUnaryOpNode(ast) {
    return ast.kind === "op_unary";
}
// Checks if the top level node is a binary op node
function checkIsBinaryOpNode(ast) {
    return ast.kind === "op_binary";
}
// Checks if top level node is a binary op node
// with a value node on the right
function checkIsBinaryOp_With_RightValue(ast) {
    return ast.kind === "op_binary" ? (0, ast_1.isValue)(ast.right) : false;
}
// Checks if top level node is a binary op node
// with a value node on the left
function checkIsBinaryOp_With_LeftValue(ast) {
    return ast.kind === "op_binary" ? (0, ast_1.isValue)(ast.left) : false;
}
// Checks if the top level node is the specified number
function checkIsNumber(ast, n) {
    return ast.kind === "number" ? ast.value == n : false;
}
function checkIsName(ast) {
    return ast.kind === "id";
}
// Checks if the top level node is the specified boolean
function checkIsBoolean(ast, b) {
    return ast.kind === "boolean" ? ast.value == b : false;
}
// bigint arithmetic
// precondition: the divisor is not zero
// rounds the division result towards negative infinity
function divFloor(a, b) {
    const almostSameSign = a > 0n === b > 0n;
    if (almostSameSign) {
        return a / b;
    }
    return a / b + (a % b === 0n ? 0n : -1n);
}
function abs(a) {
    return a < 0n ? -a : a;
}
function sign(a) {
    if (a === 0n)
        return 0n;
    else
        return a < 0n ? -1n : 1n;
}
// precondition: the divisor is not zero
// rounds the result towards negative infinity
// Uses the fact that a / b * b + a % b == a, for all b != 0.
function modFloor(a, b) {
    return a - divFloor(a, b) * b;
}
